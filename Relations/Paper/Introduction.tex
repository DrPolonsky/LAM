\section{Introduction}
\label{sec:Introduction}

% \section{Plan}
% \begin{itemize}
%   \item Start by discussing motivation
%   \item Then contributions
%   \item Plan of the paper
%   \item At some point, there should be like a summary of what's been done and what are some interesting discoveries
% \end{itemize}
%


We present a formalization of the basic Abstract Rewriting Systems (ARS) theory as presented in Term Rewriting Systems [TeReSe]
 \cite{Terese}, using the Agda proof assistant.
This work is part of a larger effort to develop a library of formalized programming language theory (PL)
at Appalachian State University.
Since Term Rewriting Systems (TRS) play a foundational role in programming languages,
while ARS encompass the basic facts about rewriting relations in general,
establishing these facts is part of the necessary infrastructure required to
pursue the broader project.  The present contribution can therefore be seen as
``bootstrapping'' Appstate's new formalized PL repository.

This broader goal also drives the main design choices in our approach.
Since rewriting theory is concerned with a fine-grained analysis of computation,
the most natural vehicle for formalizing it is type theory based on the
Curry--Howard isomorphism, which Agda implements.  Proofs in this language
are automatically effective, and implicitly carry the code that implements
a transformation from the hypotheses to the conclusion of the claim.  For example,
a type-checked proof that a given TRS is confluent automatically renders a function that
computes a common reduct between any two reducts of a given term.

Staying within this paradigm requires the proofs to be constructive.
Moreover, it requires us to avoid any axioms or postulates, such as function
extensionality, uniqueness of identity proofs, univalence, etc.
While most of ARS results are indeed constructive, standard presentations,
 including \cite{Terese}, make liberal use of classical logic.
Our paper can thus be read as a thoroughly constructive
development of elementary ARS theory.

\subsection{Motivation}

Before we proceed further, let us consider two formalization scenarios where
a constructive ARS library can be useful.

\begin{example}[Formalization of a typed lambda calculus]
Suppose one is formalizing the standard metatheory of
a typed lambda calculus.  To show confluence, one can
first establish the Church--Rosser theorem (CR) for the untyped lambda calculus,
and then proceed via the Subject Reduction theorem.
However, suppose that Strong Normalization had already been verified independently.
Invoking Newman's lemma, one can conclude confluence from the weak
diamond property --- which is generally easier to prove than full CR.
\end{example}

\begin{example}[Quotients of types]
Suppose one wishes to construct the initial model of an algebraic theory $T$
over a first-order signature $S$.
(For example, the reader could think here of the free commutative semiring over a finite set of generators.)
The classical definition involves the quotient of the term algebra $S^*$ by
the equivalence relation $\approx_T$ induced by $T$.
Direct encoding of quotients is problematic in pure type theory.
While there are a number of solutions, such as Higher Inductive Types \cite{HoTT},
Quotient Inductive--Inductive Types \cite{QIIT}, Cubical Type Theory \cite{CTT}, etc.,
they involve extending type theory with new language constructs,
incurring additional costs in complexity.

Now, suppose $T$ admits a convergent presentation.
That is, suppose that the equivalence relation on $S^*$ coincides
with conversion generated by a confluent and terminating rewriting system
$\to_R : S^* \to S^* \to \bset$.
Then one can replace $S^*/{\approx_T}$ by the type of $R$-normal forms.
(In the semiring example, these would be polynomial expressions sorted according to 
an appropriate ordering on monomials.)
This can be defined as a pure dependent type
\[ NF(R) \quad := \quad (\Sigma n : S^*) (\Pi x : S^*) \lnot (n \to_R x) \]
This type encodes the quotient in the sense that the type of functions $S^*/{\approx_T} \to A$ is isomorphic to plain functions from $NF(R)$ to $A$.
Indeed, the elimination rule for the quotient type requires every equation in $T$
to be validated in order to define a function $f : S^*/{\approx_T} \to A$.
Any such function trivially specializes to $NF(R)$.  In the other direction,
a plain function from $NF(R)$ to $A$
can be extended to all of $S^*$ by induction on normalizing reduction sequences.
Confluence ensures that $T$-equal elements are always mapped to the same value.

It follows that $S^*/{\approx_T}$ is isomorphic to $NF(R)$.

It also follows as a corollary that equality in the initial model is decidable.
\end{example}

As these examples illustrate, a fully effective implementation of basic ARS results
can be helpful in many settings arising in programming language theory.

\subsection{Formalization principles}
With the explicit goal of having the results of basic abstract rewriting
formalized in a canonical way, so that they can be used in building
libraries of formalized PL theory, we adopted the following
principles during our development.

\begin{itemize}
  \item No use of function extensionality;
  \item No use of univalence, uniqueness of identity proofs, axiom K, or any other
  assumptions related to equality;
  \item Minimize the use of classical logic, and make decidability hypotheses explicit in every place where classical logic could not be avoided;
  \item Stay as faithful as possible to the spirit of type theory based on the Curry--Howard isomorphism, so that in every concrete application, our proofs would compute.
\end{itemize}

\subsection{Decidability}
In several places, we had to assume certain decidability hypotheses in order to make
the proofs go through.  These were always flagged explicitly, and an effort was made to
have as few of them as possible.

Recall that a relation is strongly normalizing iff its converse is well-founded. \cite[Def.1.1.13]{Terese}.
Since normalization is a central concept in ARS theory,
we pay special attention to the concept of well-foundedness.
The standard constructive definition does not even allow one to show that SN implies WN, 
as we discuss in Section \ref{sec:Well-foundedness} and formalize in \texttt{WFCounters.agda}.
We therefore looked at a number of variations of this notion in the constructive context, 
their classical counterparts all being logically equivalent. %This gave rise to a rich set of concepts, see Figure \ref{f:wf}.

We have also identified classes of ARSs where the needed classical principles are simply valid.  In particular, for finitely branching relations, the implication SN to WN requires nothing else beyond plain decidability of the relation itself: $Rxy \lor \lnot Rxy$.  For example, an ARS induced by a first-order TRS with a finite set of rules is both finitely branching and decidable.

The main conclusion of our work is that most of the main ARS results can be made completely effective, at least for the practical examples encountered in first-order TRSs and lambda calculi.

For more exotic rewrite systems --- like $\lambda \bot$ (underpinning sensible lambda theories), or coinductive rewriting ---
these decidability assumptions no longer hold, and the utility of the ARS framework diminishes proportionally.

\subsection{Contributions}
Our contributions are as follows.
\begin{itemize}
  \item Formalization of elementary ARS theory as presented in
  \cite{Terese}, including relevant background;
  % Chapter 1 of
  \item An ontology of termination and confluence properties, and a detailed analysis of logical relationships between them;
  \item Definitions of new ARS concepts that refine our understanding of these relationships;
  \item Marginal improvements to classical confluence and termination criteria;
  \item An examination of several distinct notions of well-foundedness
  in the constructive setting.
\end{itemize}

\subsection{Plan of the paper}

The structure of the paper roughly corresponds with the progression of the Agda code.
% Agda files.
% (with the exception of section \ref{sec:Well-foundedness}, which is put at the end)
In the next section, we lay out the main properties of relations studied in ARS theory,
setting the ground for what follows.  In Section \ref{sec:Formalization}, we
outline our formalization of the ARS chapter from \cite{Terese}.
Here we also discuss how this effort suggested new ARS properties that helped us overcome some obstacles we encountered along the way.  These properties fit naturally within the rewriting paradigm.  Thus in Section \ref{sec:Hierarchy}, we dedicate some effort to investigating them further.  The result is a broader ontology of ARS concepts, revealing interrelationships between conditions for completeness.  In Section \ref{sec:Well-foundedness} we focus on what it means for a relation to be well-founded, identifying the classical principles needed to transition between different formulations.
We conclude with a brief summary and suggestions for future work.
