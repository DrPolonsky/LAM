module TypedLambda (ğ”¸ : Set) where

open import Logic
open import Lifting
open import Lambda

-- term2 = "Î»xÎ»y.y(Î»z.z(Î»a.ax)y)x"
term2 : Î›â‚€
term2 = abs (abs (app (app (var o ) (abs (app (app (var o)
  (abs (app (var o) (var (i (i (i o))))))) (var (i o))))) (var (i o))))

data ğ•‹ : Set where
  atom : ğ”¸ â†’ ğ•‹
  _â‡’_  : ğ•‹ â†’ ğ•‹ â†’ ğ•‹

module Curry where

{- In order to be able to express a (hypothetical) type judgment Î“ âŠ¢ t : A,
   we need to instantiate the type Î› of t at a particular set of variables V.
Hence, such a type judgment must be parametrized by the set V of free variables.

Moreover, the variables in V should all be provided a type by the context Î“.
So, "Î“ : Cxt V" should mean:
  1. dom(Î“) = V, and
  2. for each x : V, Î“ provides a type A=Î“(x) : ğ•‹
-}
  Cxt : Set â†’ Set
  Cxt V = V â†’ ğ•‹

  -- âŠ¢ is \|- or \vdash, âˆ¶ is \:
  data _âŠ¢_âˆ¶_ {V : Set} : Cxt V â†’ Î› V â†’ ğ•‹ â†’ Set where
    Var : âˆ€ {Î“ x A}      â†’  Î“ x â‰¡ A                      â†’ Î“ âŠ¢ var x âˆ¶ A
    App : âˆ€ {Î“ A B M N}  â†’  Î“ âŠ¢ M âˆ¶ (A â‡’ B) â†’ Î“ âŠ¢ N âˆ¶ A  â†’ Î“ âŠ¢ app M N âˆ¶ B
    Abs : âˆ€ {Î“ M A B}    â†’  io Î“ A âŠ¢ M âˆ¶ B               â†’ Î“ âŠ¢ abs M âˆ¶ (A â‡’ B)

  -- data _âŠ¢_âˆ¶_ {V : Set} : Cxt V â†’ Î› V â†’ ğ•‹ â†’ Set where
  --   Var : âˆ€ {Î“ : Cxt V} {x : V} {A : ğ•‹} â†’ Î“ x â‰¡ A â†’ Î“ âŠ¢ var x âˆ¶ A
  --   App : âˆ€ {Î“ : Cxt V} {M N : Î› V} {A B : ğ•‹}
  --           â†’ Î“ âŠ¢ M âˆ¶ (A â‡’ B)  â†’  Î“ âŠ¢ N âˆ¶ A  â†’  Î“ âŠ¢ app M N âˆ¶ B
  --   Abs : âˆ€ {Î“ : Cxt V} {M : Î› (â†‘ V)} {A B : ğ•‹}
  --           â†’ io Î“ A âŠ¢ M âˆ¶ B  â†’  Î“ âŠ¢ abs M âˆ¶ (A â‡’ B)

module Church where

  -- ğ‘½áµ€ : Set
  -- ğ‘½áµ€ = ğ‘½ âˆ§ ğ•‹

  -- data Î›Ch : ğ•‹ â†’ Set where
  --   var : âˆ€ {A : ğ•‹} â†’ ğ‘½ â†’ Î› A
  --   app : âˆ€ {A B : ğ•‹} â†’ Î› (A â‡’ B) â†’ Î› A â†’ Î› B
  --   abs : âˆ€ {A B : ğ•‹} â†’ ğ‘½ â†’ Î› (B) â†’ Î› (A â‡’ B)
